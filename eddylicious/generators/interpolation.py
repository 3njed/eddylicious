"""Functions for generating inflow velocity fields by
interpolation of data (from a precursor)

"""
from __future__ import print_function
from __future__ import division
import numpy as np
from mpi4py import MPI
from scipy.interpolate import interp1d
from scipy.interpolate import interp2d
from .helper_functions import chunks_and_offsets
from ..writers.ofnative_writers import write_velocity_to_ofnative
from ..writers.hdf5_writers import write_velocity_to_hdf5

__all__ = ["interpolation_generate"]

def interpolate_generate(readerFunction,
                  writer, writePath,
                  dt, t0, tEnd, timePrecision,
                  pointsY, pointsZ,
                  pointsYInfl, pointsZInfl,
                  kind,
                  times):
    """Generate the the inflow velocity interpolation.

    This function will use some precursor data and interpolate it
    on the grid at the inflow patch.

    Parameters
    ----------
    readerFunction : function
        The function to use for reading in data, generated by the
        reader. Should contain the reader's name in the attribute
        "reader".
    writer: str
        The writer that will be used to save the values of the velocity
        field.
    writePath : str
        The path for the writer.
    dt : float
        The time-step to be used in the simulation. This will be used to
        associate a time-value with the produced velocity fields.
    t0 : float
        The starting time to be used in the simulation. This will be
        used to associate a time-value with the produced velocity.
    timePrecision : int
        Number of points after the decimal to keep for the time value.
    tEnd : float
        The ending time for the simulation.
    pointsY : int
        A 1d array containing the values of y for the points of the
        source geometry.
    pointsZInfl : int
        A 1d array containing the values of z for the points of the
        source geometry.
    pointsY : int
        A 1d array containing the values of y for the points of the
        inflow boundary.
    pointsZInfl : int
        A 1d array containing the values of z for the points of the
        inflow boundary.
    times : list of floats or strings
        The times for which the velocity field was sampled in the
        precursor simulation.

    """
    # Grab info regarding parallelization
    comm = MPI.COMM_WORLD
    rank = comm.Get_rank()
    nProcs = comm.Get_size()

    # Get the total amount of rescalings to be done
    size = int((tEnd-t0)/dt+1)
    
    # Calculate the amount of rescalings each processor is responsible for
    [chunks, offsets] = chunks_and_offsets(nProcs, size)

    # Perform the rescaling
    for i in range(chunks[rank]):
        t = t0 + dt*i + dt*int(offsets[rank])
        t = float(("{0:."+str(timePrecision)+"f}").format(t))
        position = int(offsets[rank]) + i

        if (rank == 0) and (np.mod(i, int(chunks[rank]/10)) == 0):
            print("     Interpolated about "+str(int(i/chunks[rank]*100))+"%")

        # Read U data
        if readerFunction.reader == "foamFile":
            assert position < len(times)
            [uX, uY, uZ] = readerFunction(times[position])
        elif readerFunction.reader == "hdf5":
            assert position < len(times)
            [uX, uY, uZ] = readerFunction(position)
        else:
            raise ValueError("Unknown reader")

        uXInfl = interp2d(pointsZ, pointsY, uX, bounds_error=True, kind=kind)
        uYInfl = interp2d(pointsZ, pointsY, uY, bounds_error=True, kind=kind)
        uZInfl = interp2d(pointsZ, pointsY, uZ, bounds_error=True, kind=kind)

        # Write
        if writer == "ofnative":
            write_velocity_to_ofnative(writePath, t, uXInfl, uYInfl, uZInfl)
        elif writer == "hdf5":
            write_velocity_to_hdf5(writePath, t, uXInfl, uYInfl, uZInfl,
                                   position)
        else:
            raise ValueError("Unknown writer")
